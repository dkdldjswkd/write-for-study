13일 수요일 

p.1 - 설명

게임엔진의 가장 큰 구성요중 하나가 카메라이다.
유니티에서 프로젝트를 하나를 만들겠다고 하면 그 프로젝트 안에는 기본적으로 씬이 하나가 만들어지고 그 씬안에 두개의 프로젝트가 자동으로 만들어진다.



p2 - 본격적인 설명 시작
그중 하나가 메인 카메라이고 다른 하나는 디렉셔널라이트 라이트 오브젝트가 만들어진다.
그래서 유니티에서 씬이라고 표현하지만 게임기획자들은 씬을 게임 레벨, 스테이지 라고 한다.
필요하면 프로젝트가 여러개의 씬을 가지게 할 수 있고 씬이라고 하면 본질적으로 게임오브젝트의 리스트 또는 계층구조라고 한다. 수많은 게임 오브젝트가 있지만 자동으로 만들어지는 게임 오브젝트가 있고 게임 카메라라고 하는 놈을 Inspector뷰(그림 우측 상단) 트렌스폼 컨퍼넌트하고 추가적으로 카메라라는 컨포넌트가 있는것을 확일 할 수있다.
지금까지는 카메라컨포넌트가 있는지도 모르고 막 사용했다. 그리고 물론 메인카메라도 게임오브젝트이니깐 오브젝트의 회전이나 이동을 통해 스크립트를 연결하면 당연히 이 메인카메라 라고 하는 이름의 게임오브젝트도 움직이고 회전하는 것들이 가능하다. 그런데 단순한 이동과 회전이 아니라 실제 게임세상을 프로젝트가 실행이 될때 그려내는 역할을 하는 이 카메라라는 컨포넌트에 대해 이해를 하는 것이 이 단원의 목표이다. 씬 카메라는 씬 뷰에다가 현재의 씬을 그려내기 위한 카메라 이고 메인카메라는 프로젝트가 실행이 될때 게임세상을 게임뷰 또는 빌드를 하면 실행프로그램에서 그려내기 위한 카메라이여서 두개의 카메라는 다르다. 


p3
씬카메라 이외의 실제 게임세상을 그려내기 위한 게임카메라는 현제의 씬을 실제로의 씬은 게임오브젝트들의 계층 구조이니깐 게임세상에 있는 게임오브젝트들을 화면에다 그려주는 것을 렌더링이라고 한다.
유니티는 왼손좌표께를 사용, 이 게임 카메라를 통해 보는 오브젝트들을  화면에다가 그려주는 역할을 하는 컴포넌트가 카메라 컨포넌트라고 한다. 사진을 찍는것이나 동영상을 찍는 것이라고 생각하면 좋다.
카메라 컨포넌트를 이용해서 어떤 오브젝트들이든지 카메라를 추가 할 수있다. 즉 필요하면 카메라를 여러개를 만들 수 있다. 유니티에서는 카메라 컴포넌으를 가지고있는 게임오브젝트들을 카메라오브젝트 또는 단순하게 카메라라고 불른다.
일반적으로 카메라를 가지고있는 오브젝트들을 플레이어라고 한다.
일반적으로 카메라를 플레이어에 움직임에 따라 설정하면 부모(플레이어)의 움직임으로 이동과 회전을 자연스럽게 따라한다.
1인칭이라고 불리는 이유는 이 총을 들고 있는 플레이어가 직접 보는것처럼 세상을 그려내니깐 플레이어는 전혀 보이지 않지만 다른 것은 보인다.
3인칭은 플레이어의 모습도 보이고 뒤에서 카메라가 플레이어를 찍고 있는 상황, 즉 제 3자가 보는 상황이니깐 3인칭 이라고 한다. 인칭은 게임 자체가 크게 회전되는 경우는 없다. 기본적으로 사람은 하늘을 보아도 그 오브젝트 자체가 도는 것이 아니라 고개만 하늘을 바라본다. 즉 Z축으로는 특정 각도만 가능하고 그 이상은 회전이 불가능하다.
그러나 주인공(플레이어)가 비행기이면 모든 축이 회전이 가능하다.


p.4
카메라라고 하는 놈은 씬을 화면에 랜더링을 해주는 오브젝트라고 정의를 했다. 그러면 카메라는 어떻게 그 가상적인 게임 세상을 어떻게 그렸을까?
3d게임 엔진은 그래픽, input, 네트워크, 인공지능, 길찾기 등등 많은 요소가 있다. 그중 가장 3D게임 엔진은 그래픽적 내용이 기본이다. 3d 게임엔진은 무엇이 있을까? 언리얼과 유니티가 양대 산맥이다.
일반적으로 언리얼과 유니티가 있는데 왜 언리얼이 더 좋을까? 크기는 언리얼이 더 크다. 언리얼이 요구하는 기본사양은 유니티보다 높다. 그래서 다들 언리얼이 좋다고 생각한다. 하지만 언리얼 도사와 유니티 도사가 만나서 같은 조건으로 같은 작품을 만들면 둘의 차이는 크게 없다. 언리얼은 기본 세팅이 고사양이다. 하지만 유니티는 기본이 저사양으로 설정 되어있다. 즉 유니티 도사는 설정값을 바꿔서 언리얼이랑 같은 결과를 얻게 해준다. 그래서 둘의 차이는 별 차이가 없다는 것이다. 즉 게임 엔진보다는 그래픽 카드의 성능으로 퀄리티가 달라진다.
사람이 보고 느끼는 것 처럼 만들면 된다. 사람이 물체를 볼때는 물체가 있어야하고 빛이 있고 그 빛이 반사,굴절,흡수가 된다. 반산, 굴절, 흡수는 물체의 재질에 따라 달라진다. 또 에너지 보존의 법칙으로 빛의 에너지가 1이면 물체의 재질에 따라 빛을 빼았고 나오는 빛은 당연하게 약해진다. 그것 처럼 물질이 있으면 그 통과된 빛은 약해지게 처리를 해야한다.
또 빛의 반사가 없으면 물체는 보지이않는다는 과학적 사실을 게임세상에도 적용을 시켜 디렉셔널 라이트라는 태양빛을 만들어 게임뷰에서도 물체가 보이게 만들었다.
물체의 재질은 빛의 반사의 성질을 표현한다. 빛을 통과하는지 (유리), 빛을 반사하는지(거울, 금속), 빛의 반사를 그때그때 다르게 표현하는지(물)
엔진에서 이미 구현을 해서 어떤 물체가 어떠한 재질을 가지고있는지만 잘 알려주면 엔진에서 알아서 빛을 반사시켜 카메라에 보여준다.


p.5
흔히 3d로 구성된 게임세상을 3차원 세상이라고 한다. 3d를 시각적으로 볼 수 있게 하는 기계 장치가 존재한다(홀로그램). 하지만 홀로그램은 아직 상용화되지 않고 지금 대부분의 디스플레이 장치는 2d화면(평면) 즉 3d로 표현된 게임세상을 2d화면으로 바꾸어서 그리는 과정이 필요하다. 흔히 그린다라고 표현하는 드로우, 페인트에서 드로우는 윤곽, 페인트는 색칠을 생각하지만 랜더링은 입체를 2d화면에 보여주는것. 그 과정에서 여러가지 일들이 일어나는데 나중에 조명 등을 총해서 알아본다.


p.6
그림을 보면 조명에서 나오는 빛이 어떤 물체의 표면에 한번만 반사가 되어서 카메라에 들어오면 직접 조명이라하고 오브젝트에 두번이상 반사가 되어서 들어오면 간접 조명이라고 한다. 
즉 보라색 기둥에 백색 빛이 반사가 되면 보라색 빛으로 변하고 그 후 갈색 오브젝트에 빛이 반사가되면 바뀐 빛을 표현하는데 많은 시간과 계산이 필요함. 어떤 프로그램을 실행을 하면 사용자가 어떤 입력을 주고 씬의 변화를 화면에 그려내는 한 과정을 프레임이라고한다. 한 프레임은 사진이라고 생각하면 편하다. 한프레임은 1초에 60번 해줘야한다. 프레임 레이트(프레임의 폭)가 폭이 갑자기 넓어지고 커지면 플레이어들은 컴퓨터가 렉이 걸린줄 알고 이미 컴퓨터를 재부팅한다. 그래서 프레임레이트가 가장 중요함


p.7
하나의 씬에는 카메라가 여러개가 있을 수 있다. 각각의 컴포넌트들이 활성화 되있으면 여러개의 무조건 카메라 컨포넌트는 자기가 보는 방향의 게임오브젝트들 씬들을 화면에다가 2D로 그리려고 한다. 조명계산, 형태계산등 을 해서.
depth는 카메라가 두개이상 있을때 화면이라는것은 하나인데 그림을 그릴 떄 어떤 카메라를 먼저 그릴지 순서를 정하는 것이다. 둘다 0, 0 이니깐 마음대로 할 수 있다.
그림의 왼쪽(진짜 메인카메라)은 3D세상을 다 보여주는 카메라, 그림의 오른쪽(2D, UI, 미니맵)만  그리는 카메라라로 설정 가능.
레이싱 게임을 보면 플레이어 눈으로 보는 카메라, 백미러, 사이드 미러등 카메라가 존재한다. 여러개의 카메라가 한 화면에 모두 보이게 할 수도 있는 것이다. 여기서 Depth가 카메라를 그려주는 순서를 정해준다.
경비실을 보면 하나의 화면에 1번~4번카메라까지 총 분할해서 보여주는 경우도 있다. 이럴 때 정확한 수치로 나뉘어서 분할하면 문제가 전혀 없지만 겹치게 분할하면 문제가 발생한다(강의 갑자기 끝나서 못적음 그냥 부정적인 효과가 있음)
다시 정리하면 depth는 카메라가 랜더링 하는 순서를 의미한다. 수치가 작은것이 먼저 그려지고 화면이라는 것은 스크린에 카메라가 여러개가 있어도 공유를 하니깐 먼저 그리고 또다른 카메라를 똑같은 위치에 그리면 나중에 그린 카메라만 화면에 나올 것이다. 유니티 버전이 계속 업그레이드 되면서 일부 내용이 추가되었지만 내용은 거의 비슷하다.
Clear Flags는 카메라는 3D 씬을 화면에다가 그리려고 하는것. 즉 3d세상을 2d(씬)에 그리는것을 수행해야하는데 그 종이를 어떻게 지울 것인가? 를 정하는 것이다. 
projection투영. 즉 perspective는 3D용도, Othographic는 2D용도


p.11
투영부터 알아가보자. 3차원은 x, y, z로 나와있는데 2d로 구현할거면 x, y로 구현되어있다. 즉 3차원을 2차원으로 바꿀거면 x/z, y/z, 1로 바꾼다. 왜 이렇게 z로 나눠서 바꿔줄까? 그 이유는 바로 1은 있으나마나라서. (x/z, y/z, 1)과 (x/z,, y/z)가 같은 것을 수학적 표현으로 동차라고한다. 1을 넣으면 3차원, 1을 빼면 2차원.
vanishing point는 화면이 멀어질수록 한점으로 모이는 효과를 의미. 즉 원근감을 가지고있으면 무조건 성립한다.
기차길을 보면 왼손좌표계를 이용해서 (1, 0, 10)이다. 기차길 끝을 보면 (1, 0, 20000)이다. 그럼 위에서 설명한것처럼 z로 나누어주면 (1/20000, 0, 1)이 되는데 만약에 아주 먼곳으로 가정하면 (1/무한대, 0/무한대, 1)이 된다. 그러면 자연스럽게 화면의 가운데로 모여진다. 이것이 베니싱포인트이다. 이렇게 나누는 과정을 원근투영나누기 라고 한다.
그림자도 생각해보자. 빛에 가까이 가면 그 물체의 그림자는 커지고 빛과 멀리가면 그 물체의 그림자는 작아진다. 이런것이 다 투영이다. 
이제 원근을 생각해보면 예시로 이하하면 쉽다. 가까이 있는 차는 내앞에서 빠르게 사라지는데 멀리있는 차는 한참 걸려서 내 시야게서 사라진다.
직교투영은 z를 버리던지 무시하는 것이다. 즉 원근적인 표현이 없다는 것이다. 기차길을 보면 베니싱포인트가 성립되지 않고 멀고 가까운것이 차이가 없다는 것이다. 그래서 대표적으로 직교투영은 멀고 가까운것이 상관없는 UI, 2d게임에 사용 된다.


p. 12
Field of view(시야각)
사진을 찍을 때 일정한 범위를 나가면 사진을 찍을 수 없다. 사람는 뒤를 볼 수가 없다. 그이유는 사람의 시야각이 정해져있기 때문이다. 시야각을 넘어가면 투영이 안됨.
카메라는 시야각으로 사각뿔을 형태로 구성되었으면 너무 멀어 안보이는 곳의 끝과 너무 가까워서 안보이는 시작점을 찾고 사각형이 생기는데 그것이 근평면(NearPlane), 멀리 있는 사각형은(FarPlane)이 생김.
즉 이 평면을 잘라내면 육면체가 생긴다.
시야각이 120도이면 보이는 오브젝트들이 훨씬 많아진다. 부피역시 엄청 많이 늘어난다. 시야각이 넓으면 속도감이 없고 넓고 많은 것을 볼 수 있으며 오브젝트들이 작게 보이는 효과가 있다. 시야각이 좁아지면 속도감이 있고 일부분만 보이고 오브젝트들이 크게 보이는 효과가 있다.
레이싱게임은 속도감을 위해 시야각을 좁게한다. 그러나 배경을 보는 3D 대규모 게임은 시야각을 넓게한다.
즉 시야각이 넓으면 많은 오브젝트가 있을 것이고 그러면 프레임레이트가 떨어져서 렉걸리는 현상처럼 보일것이다.
그럼 시야각이 65도와 60도의 차이가 있을까? 있다. 5도의 차이라도 오브젝트가 많이 사라진다. 그러면 프레임레이트를 좋아진다. 즉 게임은 프레임레이트가 가장 중요하다. 아무리 게임을 잘만들고 그래픽이 좋아도 프레임레이트가 10, 15로 렉거린는 효과가 걸리면 게임을 아무도 안할 것이다. 



p.8
Clipping Planes는 잘라버리는 것 p.12에서 설명한 Near Plane과 Far Plane이 있고 좀더 세부적드로 설명하자면 복도가 주 배경이면 Far수치는 길어봤지 50도 안될것이고 실내에서는 더더욱 적어야한다.
만약에 교실에서도 far수치를 넓이면 벽이 있어도 무시하고 절두체의 모든 오브젝트를 보려고 한다. 즉 프레임레이트가 낮아짐. 
뷰포트는 화면에있는 영역에 그려지는 것으로 모두 2d로 설정되어야한다.
화면 640x480을 보자. 640을 1로 두고 0~640을 0~1로 바꾸어 노멀라이즈된 좌표로 뷰포트를 표현한다.
화면의 크기만큼의 메모리를 그래픽카드가 내부적으로 만드는데 Render Target이라고 한다. 즉 여기에 그림이 다 저장이 되는 Clear Flags 설정으로 지우는 것이다. skybox는 기본값으로 하늘이 있고 땅이 있는 기본 방식.
solid color는 색으로 설정. don't clear은 안지우겠다. 기존에 그림이 있는 그 위에 그릴 것이다. 왜 이렇게 지우지 않고 그림을 그릴까? 지울필요가 없고 지우면 안되기때문이다. 그 이유는 직교투영카메라 즉 UI카메라를 설정할 때 기본적으로 가장 마지막에 설정을 한다. 내가 기존에 만들었던 그림들 위에 설정을 해야하는데 만약에 skybox, solid color를 사용하면 Render Target이 지워져서 기존 그림도 지워져버린다. 그러면 UI설정을 하는데 문제가 생김.
Depth Only는 렌더링 순서 Depth와는 다른것으로 깊이 값 이라고하는 의미가 된다.
Depth버퍼 알고리즘 : Depth를 모두 1로 주고 작은 숫자인 즉 카메라와 가장 가까운 물체를 먼저 그린다. 그 물체의 값은 0.5라고 하자. 그 후 0.7에 있는 다른 물체를 가져와서 비교한다. 작은 값이 카메라와 더 가까이 있으므로 큰값은 무시하고 작은값을 가져온다.
이러한 것을 지우기 위해 Depth Only가 있는 것이다.

