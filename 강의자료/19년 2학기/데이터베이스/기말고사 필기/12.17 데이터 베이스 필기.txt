트랜잭션
특징 : 동시성제어, 회복

데이터 베이스 응용의 오작동
320명째 사원까지 급여를 6%인상 컴퓨터 시스템이 다운됨
-> 인상된 사원과 인상되지 않은 사원을 구분할 수 있나??

트랜잭션 ACID 특성 (★중요★)
A. 원자성, C.일관성, I. 고립성, D. 지속성
원자성 - 모두 수행되거나 혹은 전혀 수행되지 않거나
일관성 - 트랜잭션이 수행되기 전 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 또 다른 일관된 상태를 가짐
트랜잭션 수행중에는 비일관된 상태여도 끝날때만 일관된 상태이면 됨.
비일관된 상태이면 트랜잭션이 수행되도 비일관된 상태임
일관된상태 (데이터의 무결성이 모두 지켜지고 있는 상태)
고립성 - 여러 트랜잭션이 동시에 수행되더라도 마치 혼자 수행한 것과 같아야 함
(비직렬적으로 수행하더라도 결과가 같으면 인정해준다 -> 직렬화 가능한 스케쥴)
지속성 - 트랜잭션이 완료되면 무슨일이 있어도 그 결과를 유지함

성공한 종료 -> 커밋 / 실패한 종료 -> 롤백(원자성)

직렬 스케쥴 - 하나씩 순서대로 트랜잭션을 실행한다 (데이터 베이스의 일관성이 보장됨 but 성능 보장이 안됨, 느리다)
타임 쉐어링 - 성능이 올라감 but 여러 트랜잭션을 동시에 실행하면 일관성을 보장하지 못한다 (고립성으로 해결)

데이터 베이스의 목적
1. 데이터를 안전하게 지키는것 (데이터의 일관성이 회손되지 않게) (원자성, 일관성)
2. 효과적으로 잘 관리하는것

동시성제어 ★★ 시험에 나옴 ★★
직렬 스케줄 : 여러 트랜잭션들의 집합을 한번에 한 트래잭션씩 차례대로 수행함 일관성이 유지됨 (원자성, 일관성 때문에)
비직렬 스케줄 : 여러 트랜잭션들을 동시에 수행함 일관성을 보장못함 (고립성으로 해결)

동시성 제어 오류 (데이터가 깨질 수 있다.)
1. 갱신 손실, 2. 오손 데이터 읽기(dirty read), 3. 반복할 수 없는 읽기 (1이 가장큰문제, 3이 가장 작은 문제)
갱신손실 - 수행중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀, 갱신 무효
오손 데이터 읽기 - 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는것 (롤백이 된 트랜잭션의 값을 읽어온다)
반복할 수 없는 읽기 - 읽을때마다 값이 달라짐 (고립성이 깨짐)

고립화 수준(4단계가 있음) : 한 트랜잭션이 다른 트랜잭션과 고립되는 정도
고립 수준이 낮으면 동시성은 높아지지만 데이터의 정확성은 떨어짐
고립 수준이 높으면 데이터가 정확해지지만 동시성이 저하됨
-> 응용분야에 따라 <일관성, 동시성>이 결정됨 -> 반비례함