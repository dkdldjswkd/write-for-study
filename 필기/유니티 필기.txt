// 순간이동식으로 위치를 이동시킴
transform.position = new Vector3 (10, 0, 0);
RigidBody.position

// 이동 출발과 끝 지점을 직선으로 연결한 경로를 매우 빠르게 이동한다
(중간에 다른 rigidbody가 있을 시 밀어내는 등의 물리처리를 한다)
RigidBody.MovePosition()
ex ) myRigid.MovePosition(transform.position + _velocity * Time.deltaTime);
ex ) myRigid.MoveRotation(myRigid.rotation * Quaternion.Euler(_characterRotationY));
ex ) RigidBody.velocity = new Vector3 (0,10,0);

// 위치 이동 메소드
transform.Translate(Vector3.right * Time.deltaTime); // 현재 게임오브젝트의 위치를 기준으로 상대적인 Vector3의 방향으로 이동한다.

//피직스, 레이져
IsGround = Physics.Raycast(transform.position, Vector3.down, capsuleCollider.bounds.extents.y + 0.1f); // 어디서, 방향, 길이 or 어디서, 방향, RaycastHit, 길이
Ray ray =  Camera.main.ScreenPointToRay(Input.mousePosition); // 메인카메라에서 스크린으로 쏘는 레이저, 마우스 포지션 좌표에
Ray ray = new Ray(transform.position, transform.forward); // ~에서, ~방향으로
RaycastHit // 광선을 쏴서 그 정보를 얻어올때 쓰는 자료형
Plane.Raycast(Ray _r, out float _f) // 특정 평면과 Ray와의 충돌을 체크하여  Ray의 Origin으로부터 충돌지점까지의 거리를 _f에 저장하여 줍니다.
Vector3 point = ray.GetPoint(rayDistance); // ray의 rayDistance 거리에 충돌한 위치값을 반환함
ray.origin // ray의 시작부분
Debug.DrawLine(ray.origin, point, Color.red); // 시작부분, 끝부분, 색 으로 선을 그려줌

//스크립트에서 애니메이션 파라미터 관리
currentGun.anim.SetBool("Walk", true);

//유니티 씬 로드 하기
using UnityEngine.SceneManagement; // 인클루드
SceneManager.LoadScene(sceneName); // 씬 로드해옴

//게임 오브젝트 이동
Input.GetAxis(string name)
-1.0f 부터 1.0f 까지의 범위의 값을 반환한다. 즉, 부드러운 이동이 필요한 경우에 사용된다.
Input.GetAxisRaw(string name)
-1, 0, 1 세 가지 값 중 하나가 반환된다. 키보드 값을 눌렀을 때 즉시 반응해야한다면 GetAxisRaw를 사용하면 된다

//게임 오브젝트 회전
myRigid.MoveRotation( transform.rotation *  Quaternion.Euler( rotationY ) ); // 매개변수 값은 쿼터니언임.
transform.rotation // 이것또한 쿼터니언
transform.LookAt(Vector3); // Vector3 좌표로 오브젝트를 바라보게함
//게임 오브젝트 addForce, 점프할때 쓰임
rigidbody.AddForce(Vector3.up * power, ForceMode.Impulse); // (벡터, 포스모드)

//게임 오브젝트 활성화, 비활성화
gameobject.SetActive(false); // gameobject를 비활성화 시킴, (true는 활성화)

//게임 오브젝트 생성
GameObject emptyGameObject = new GameObject("name"); //name이라는 빈 게임 오브젝트를 생성
A a = Instantiate(GameObject original ,Vector3 position ,Quaternion rotation) as A; // A의 인스턴스를 동적할당;

//게임 오브젝트 제거
Destroy(GameObject obj ,float time); // time 만큼 지연 후 삭제 (필수 파라메터 x)

//정규화
Vector3.normalized;

//카메라
히어라이키 탭 에서 메인카메라를 선택후 컨트롤 + 쉬프트 + F //현재 보고있는 씬을 카메라가 그대로 바라보게 하기
camera.main; // MainCamera 태그가 붙은 오브젝트를 반환한다

//에드 컴포넌트
gameObject.AddComponent ("FoobarScript"); // FoobarScript로 명명된 스크립트를 게임오브젝트에 추가한다
gameObject.AddComponent .AddComponent<스크립트이름>();

//컴포넌트를 보장(?)하는 코드
[RequireComponent(typeof(Rigidbody))] // 이 게임오브젝트는 반드시 Rigidbody를 갖고 있어야 한다는 의미이다. 따라서, Rigidbody 컴포넌트를 삭제할 수 없다.

//monobehaviour 내장 함수
FixedUpdate(); // 모든 물리적 단계 호출, 물리 객체 조정과 같은 정기적 업데이트에 사용(RigidBody)
--------------------------URL-------------------------------
//유니티 애니메이션
https://blog.naver.com/gold_metal/220490285634

// 오브젝트 회전, 이동 함수
https://mingyu0403.tistory.com/22

// 코루틴 알고리즘 설명
https://onecoke.tistory.com/entry/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-Coroutine

--------------------------기타, 용어-------------------------
// 용어
파라미터 == 매개변수

// 유니티 코딩 스킬
스크립트마다 static bool 변수로 스크립트를 활성화, 비활성화 시킬 수 있음
--------------------------정리 전 ----------------------------